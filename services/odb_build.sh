#!/usr/bin/env bash
# ODB + dbparser build pipeline (no-args)
# ROOT_DIR is detected to be the project "services" folder that contains:
#   - CMakeLists.txt
#   - include/database
#   - schemas/
# Then:
#   - configure & build dbparser
#   - run dbparser on schemas/database.dsl
#   - run ODB codegen, retarget #includes to <database/*.hxx>, emit schema.sql

set -euo pipefail

log(){ echo "[odb_build] $*"; }
err(){ echo "[odb_build][ERR] $*" >&2; }

VERBOSE=false
vrun(){ $VERBOSE && { echo "+ $*"; "$@"; } || "$@"; }

# --- locate ROOT_DIR (prefer the script's own directory = services) ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR=""
for cand in "$SCRIPT_DIR" "$SCRIPT_DIR/.." "$SCRIPT_DIR/../.."; do
  if [[ -d "$cand/include/database" && -f "$cand/CMakeLists.txt" ]]; then
    ROOT_DIR="$(cd "$cand" && pwd)"
    break
  fi
done
# Fallback to the script folder if heuristics fail.
: "${ROOT_DIR:="$SCRIPT_DIR"}"

log "ROOT_DIR:  $ROOT_DIR"

# --- resolve DSL_PATH (prefer services/schemas/database.dsl, otherwise first *.dsl) ---
DSL_PATH="$ROOT_DIR/schemas/database.dsl"
if [[ ! -f "$DSL_PATH" ]]; then
  if mapfile -t _dsl < <(find "$ROOT_DIR/schemas" -maxdepth 1 -type f -name '*.dsl' | sort); then
    if (( ${#_dsl[@]} > 0 )); then
      DSL_PATH="${_dsl[0]}"
      log "DSL_PATH auto-detected: $DSL_PATH"
    fi
  fi
fi
[[ -f "$DSL_PATH" ]] || { err "DSL not found under $ROOT_DIR/schemas (expected database.dsl)."; exit 1; }
log "DSL_PATH:  $DSL_PATH"

# --- tool checks ---
command -v cmake >/dev/null || { err "'cmake' not found"; exit 1; }
command -v make  >/dev/null || { err "'make' not found"; exit 1; }
command -v odb   >/dev/null || { err "'odb' not found"; exit 1; }

# --- paths ---
BUILD_DIR="$ROOT_DIR/build"
RELEASES_DIR="$ROOT_DIR/releases"
DBPARSER_BIN="$RELEASES_DIR/dbparser"

SRC_DIR="$ROOT_DIR/include/database"   # entity .h generated by dbparser
OUT_INCLUDE="$ROOT_DIR/include/database"  # .hxx/.ixx
OUT_SRC="$ROOT_DIR/src/odb/src"           # .cxx
OUT_SCHEMA="$ROOT_DIR/schemas"            # schema.sql

ODB_INCLUDE_PATHS="${ODB_INCLUDE_PATHS:-$ROOT_DIR/include:/usr/include}"
DB_BACKEND="${DB_BACKEND:-pgsql}"
STD="${STD:-c++17}"
INPUT_NAME="${INPUT_NAME:-all_models}"
EXCLUDES=(database db_object db_types models all_models-odb)

# --- 1) Build dbparser ---
log "Configuring & building dbparser…"
mkdir -p "$BUILD_DIR"
if [[ ! -f "$BUILD_DIR/CMakeCache.txt" ]]; then
  vrun cmake -S "$ROOT_DIR" -B "$BUILD_DIR" -DCMAKE_BUILD_TYPE=Release
fi
vrun cmake --build "$BUILD_DIR" --target dbparser -j

[[ -x "$DBPARSER_BIN" ]] || { err "dbparser not found: $DBPARSER_BIN"; exit 1; }

# --- 2) Run dbparser (outputs your entity headers into include/database) ---
log "Running dbparser on DSL…"
vrun "$DBPARSER_BIN" "$DSL_PATH" "$ROOT_DIR"

[[ -d "$SRC_DIR" ]] || { err "No entity headers dir: $SRC_DIR"; exit 1; }

# --- 3) ODB codegen ---
mkdir -p "$OUT_INCLUDE" "$OUT_SRC" "$OUT_SCHEMA"
TMP="$(mktemp -d /tmp/odb_build.XXXXXX)"; trap 'rm -rf "$TMP"' EXIT

# Collect headers to feed into ODB
mapfile -d '' HEADERS < <(
  find "$SRC_DIR" -maxdepth 1 -type f -name '*.h' -print0 |
  while IFS= read -r -d '' f; do
    b="${f##*/}"; b="${b%.*}"
    for ex in "${EXCLUDES[@]}"; do [[ "$b" == "$ex" ]] && continue 2; done
    [[ "$b" == *-odb* || "$b" == all_models ]] && continue
    printf '%s\0' "$f"
  done | sort -z
)
(( ${#HEADERS[@]} )) || { err "No entity headers found in $SRC_DIR"; exit 1; }

# Build include flags from ODB_INCLUDE_PATHS
COMMON_I=()
IFS=':' read -r -a _incs <<< "$ODB_INCLUDE_PATHS"
for inc in "${_incs[@]}"; do [[ -n "$inc" ]] && COMMON_I+=( -I"$inc" ); done

HIX=( --hxx-suffix .hxx --ixx-suffix .ixx --cxx-suffix .cxx )
MODE=( --at-once --input-name "$INPUT_NAME" )
WRAP=$'#include <boost/optional.hpp>\n#include <odb/boost/optional/wrapper-traits.hxx>\n'

ODB_FLAGS=( -d "$DB_BACKEND" --std "$STD" "${COMMON_I[@]}" --generate-query "${MODE[@]}" "${HIX[@]}" --odb-prologue "$WRAP" --hxx-prologue "$WRAP" --default-pointer std::shared_ptr )
SCHEMA_FLAGS=( -d "$DB_BACKEND" --std "$STD" "${COMMON_I[@]}" --generate-schema --schema-format sql "${MODE[@]}" "${HIX[@]}" --odb-prologue "$WRAP" --hxx-prologue "$WRAP" --default-pointer std::shared_ptr )

log "Generating ODB sources to temp: $TMP"
odb "${ODB_FLAGS[@]}" -o "$TMP" "${HEADERS[@]}"

shopt -s nullglob
mv -f "$TMP"/*.hxx "$TMP"/*.ixx "$OUT_INCLUDE/" 2>/dev/null || true
mv -f "$TMP"/*.cxx "$OUT_SRC/" 2>/dev/null || true
shopt -u nullglob

# Retarget #include "xxx.hxx" -> #include <database/xxx.hxx>
changed=0
shopt -s nullglob
for f in "$OUT_SRC"/*.cxx "$OUT_INCLUDE"/*.ixx "$OUT_INCLUDE"/*.hxx; do
  [[ -f "$f" ]] || continue
  before="$(md5sum "$f" | awk '{print $1}')"
  perl -0777 -pi -e 's{(^\s*#\s*include\s*)"(?:[^"/]*/)?([^"/]+\.hxx)"}{$1<database/$2>}mg;' "$f"
  after="$(md5sum "$f" | awk '{print $1}')"
  [[ "$before" != "$after" ]] && ((changed++))
done
shopt -u nullglob
log "Include retargeting done (${changed} files updated)."

# Schema
log "Generating SQL schema…"
SCHEMA_OUT="$OUT_SCHEMA/schema.sql"; rm -f "$SCHEMA_OUT"
odb "${SCHEMA_FLAGS[@]}" -o "$TMP" "${HEADERS[@]}"
if ls "$TMP"/*.sql >/dev/null 2>&1; then
  cat "$TMP"/*.sql > "$SCHEMA_OUT"
  log "Schema written to: $SCHEMA_OUT"
else
  err "No .sql emitted by ODB."
fi

PARENT_INCLUDE="$(cd "$OUT_INCLUDE/.." && pwd)"
log "Done. Add -I\"$PARENT_INCLUDE\" so #include <database/...> resolves."